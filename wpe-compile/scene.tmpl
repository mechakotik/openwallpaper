{{define "scene"}}// autogenerated by wpe-compile

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "openwallpaper.h"
#include "scene_utils.h"

{{range $_, $texture := .Textures}}ow_id texture{{$texture.ID}}; // {{$texture.Name}}
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_header" $shader}}
{{end}}{{range $_, $pass := .Passes}}ow_id object{{$pass.ObjectID}}_pass{{$pass.PassID}}_pipeline;
{{end}}
{{range $_, $particle := .Particles}}particle_t particle{{.ObjectID}};
{{end}}

typedef struct {
    float position[3];
    float texcoord[2];
} vertex_data_t;

typedef struct {
    float texcoord[2];
} particle_vertex_data_t;

typedef struct {
    glsl_mat4 mvp;
} particle_vertex_uniforms_t;

typedef struct {
    glsl_ivec2 spritesheet_size;
} particle_fragment_uniforms_t;

vertex_data_t vertex_quad[4] = {
    { {-1.0f, -1.0f, 0.0f}, {0.0f, 1.0f} },
    { { 1.0f, -1.0f, 0.0f}, {1.0f, 1.0f} },
    { {-1.0f,  1.0f, 0.0f}, {0.0f, 0.0f} },
    { { 1.0f,  1.0f, 0.0f}, {1.0f, 0.0f} },
};

particle_vertex_data_t particle_vertex_data[4] = {
    { {0.0f, 1.0f} },
    { {1.0f, 1.0f} },
    { {0.0f, 0.0f} },
    { {1.0f, 0.0f} },
};

ow_vertex_attribute vertex_attributes[2] = {
    { .slot = 0, .location = 0, .type = OW_ATTRIBUTE_FLOAT3, .offset = 0 },
    { .slot = 0, .location = 1, .type = OW_ATTRIBUTE_FLOAT2, .offset = sizeof(float) * 3 },
};

ow_vertex_attribute particle_vertex_attributes[6] = {
    { .slot = 0, .location = 0, .type = OW_ATTRIBUTE_FLOAT2, .offset = 0 },
    { .slot = 1, .location = 1, .type = OW_ATTRIBUTE_FLOAT3, .offset = 0 },
    { .slot = 1, .location = 2, .type = OW_ATTRIBUTE_FLOAT3, .offset = sizeof(float) * 3 },
    { .slot = 1, .location = 3, .type = OW_ATTRIBUTE_FLOAT, .offset = sizeof(float) * 6 },
    { .slot = 1, .location = 4, .type = OW_ATTRIBUTE_FLOAT4, .offset = sizeof(float) * 7 },
    { .slot = 1, .location = 5, .type = OW_ATTRIBUTE_INT, .offset = sizeof(float) * 11 },
};

ow_id screen_buffer = 0;
uint32_t screen_buffer_width, screen_buffer_height;

ow_id temp_buffers[{{len .TempBuffers}}];
ow_id temp_screen_buffers[{{len .TempScreenBuffers}}];

ow_id vertex_quad_buffer;
ow_id particle_vertex_data_buffer;

ow_id linear_clamp_sampler;
ow_id linear_repeat_sampler;
ow_id nearest_clamp_sampler;
ow_id nearest_repeat_sampler;

ow_id particle_vertex;
ow_id particle_fragment;

ow_texture_info texture_info = {
    .mip_levels = 1,
    .format = OW_TEXTURE_RGBA8_UNORM,
};

float time = 0.0f;
float mouse_x = 0.0f;
float mouse_y = 0.0f;
float parallax_mouse_x = 0.0f;
float parallax_mouse_y = 0.0f;
bool parallax_initialized = false;
int scale_mode = SCALE_MODE_ASPECT_CROP;

__attribute__((export_name("init"))) void init() {
    const char* scale_mode_opt = ow_get_option("scale-mode");
    if(scale_mode_opt != NULL) {
        if(strcmp(scale_mode_opt, "stretch") == 0) {
            scale_mode = SCALE_MODE_STRETCH;
        } else if(strcmp(scale_mode_opt, "aspect-fit") == 0) {
            scale_mode = SCALE_MODE_ASPECT_FIT;
        } else if(strcmp(scale_mode_opt, "aspect-crop") == 0) {
            scale_mode = SCALE_MODE_ASPECT_CROP;
        } else {
            printf("warning: unknown scale mode, defaulting to aspect-crop\n");
        }
    }

    ow_begin_copy_pass();

    vertex_quad_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(vertex_quad));
    ow_update_buffer(vertex_quad_buffer, 0, vertex_quad, sizeof(vertex_quad));
    particle_vertex_data_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(particle_vertex_data));
    ow_update_buffer(particle_vertex_data_buffer, 0, particle_vertex_data, sizeof(particle_vertex_data));

{{if ne (len .Particles) 0}}
    particle_vertex = ow_create_shader_from_file("assets/particle_vertex.spv", OW_SHADER_VERTEX);
    particle_fragment = ow_create_shader_from_file("assets/particle_fragment.spv", OW_SHADER_FRAGMENT);
{{end}}

{{range $idx, $buffer := .TempBuffers}}
    {
        ow_texture_info temp_buffer_info = {
            .width = {{$buffer.Width}},
            .height = {{$buffer.Height}},
            .format = OW_TEXTURE_RGBA8_UNORM,
            .render_target = true,
            .mip_levels = 1,
        };

        temp_buffers[{{$idx}}] = ow_create_texture(&temp_buffer_info);
    }
{{end}}

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_LINEAR,
            .mag_filter = OW_FILTER_LINEAR,
            .mip_filter = OW_FILTER_LINEAR,
            .wrap_x = OW_WRAP_CLAMP,
            .wrap_y = OW_WRAP_CLAMP,
        };

        linear_clamp_sampler = ow_create_sampler(&sampler_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_LINEAR,
            .mag_filter = OW_FILTER_LINEAR,
            .mip_filter = OW_FILTER_LINEAR,
            .wrap_x = OW_WRAP_REPEAT,
            .wrap_y = OW_WRAP_REPEAT,
        };

        linear_repeat_sampler = ow_create_sampler(&sampler_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_NEAREST,
            .mag_filter = OW_FILTER_NEAREST,
            .mip_filter = OW_FILTER_NEAREST,
            .wrap_x = OW_WRAP_CLAMP,
            .wrap_y = OW_WRAP_CLAMP,
        };

        nearest_clamp_sampler = ow_create_sampler(&sampler_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_NEAREST,
            .mag_filter = OW_FILTER_NEAREST,
            .mip_filter = OW_FILTER_NEAREST,
            .wrap_x = OW_WRAP_REPEAT,
            .wrap_y = OW_WRAP_REPEAT,
        };

        nearest_repeat_sampler = ow_create_sampler(&sampler_info);
    }

{{range $_, $texture := .Textures}}    texture{{$texture.ID}} = ow_create_texture_from_webp("assets/texture{{$texture.ID}}.webp", &texture_info);
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_init" $shader}}{{end}}
{{range $_, $pass := .Passes}}{{template "pass_init" $pass}}
{{end}}
{{range $_, $particle := .Particles}}{{template "particle_init" $particle}}
{{end}}

    ow_end_copy_pass();
}

__attribute__((export_name("update"))) void update(float delta) {
    uint32_t screen_width, screen_height;
    ow_get_screen_size(&screen_width, &screen_height);

    if(screen_width != screen_buffer_width || screen_height != screen_buffer_height) {
        ow_texture_info screen_buffer_info = {
            .width = screen_width,
            .height = screen_height,
            .format = OW_TEXTURE_RGBA8_UNORM,
            .render_target = true,
            .mip_levels = 1,
        };

        ow_free(screen_buffer);
        screen_buffer = ow_create_texture(&screen_buffer_info);

{{range $idx, $buffer := .TempScreenBuffers}}
        screen_buffer_info.width = screen_width * {{$buffer.ScaleX}};
        screen_buffer_info.height = screen_height * {{$buffer.ScaleY}};
        ow_free(temp_screen_buffers[{{$idx}}]);
        temp_screen_buffers[{{$idx}}] = ow_create_texture(&screen_buffer_info);
{{end}}

        screen_buffer_width = screen_width;
        screen_buffer_height = screen_height;
    }

    ow_get_mouse_state(&mouse_x, &mouse_y);
    if(screen_width != 0 && screen_height != 0) {
        mouse_x /= screen_width;
        mouse_y /= screen_height;
    }

    if(!parallax_initialized) {
        parallax_mouse_x = mouse_x;
        parallax_mouse_y = mouse_y;
        parallax_initialized = true;
    }
    if({{.Parallax.Enabled}}) {
        float factor = 1 - exp(-delta * 12.0f / {{.Parallax.Delay}});
        parallax_mouse_x += (mouse_x - parallax_mouse_x) * factor;
        parallax_mouse_y += (mouse_y - parallax_mouse_y) * factor;
    } else {
        parallax_mouse_x = mouse_x;
        parallax_mouse_y = mouse_y;
    }

    ow_begin_copy_pass();

{{range $_, $particle := .Particles}}
    update_particle(&particle{{.ObjectID}}, delta);
    update_particle_instance_data(&particle{{.ObjectID}});
    ow_update_buffer(particle{{.ObjectID}}.instance_buffer, 0, particle{{.ObjectID}}.instance_data, sizeof(particle_instance_data_t) * {{.MaxCount}});
{{end}}

    ow_end_copy_pass();

    time += delta;
{{range $_, $pass := .Passes}}
{{template "pass_update" $pass}}{{end}}
}

{{end}}

{{define "shader_header"}}// {{.NameInfo}}
ow_id shader{{.ID}}_vertex;
ow_id shader{{.ID}}_fragment;

{{.VertexUniformsStruct}}
{{.FragmentUniformsStruct}}
{{end}}

{{define "shader_init"}}    shader{{.ID}}_vertex = ow_create_shader_from_file("assets/shader{{.ID}}_vertex.spv", OW_SHADER_VERTEX);
    shader{{.ID}}_fragment = ow_create_shader_from_file("assets/shader{{.ID}}_fragment.spv", OW_SHADER_FRAGMENT);
{{end}}

{{define "particle_init"}}    {
    particle{{.ObjectID}} = (particle_t){
        .emitters = calloc({{len .Emitters}}, sizeof(particle_emitter_t)),
        .init = {
            .min_lifetime = {{.Init.MinLifetime}},
            .max_lifetime = {{.Init.MaxLifetime}},
            .min_size = {{.Init.MinSize}},
            .max_size = {{.Init.MaxSize}},
            .min_velocity = {
                {{index .Init.MinVelocity 0}},
                {{index .Init.MinVelocity 1}},
                {{index .Init.MinVelocity 2}},
            },
            .max_velocity = {
                {{index .Init.MaxVelocity 0}},
                {{index .Init.MaxVelocity 1}},
                {{index .Init.MaxVelocity 2}},
            },
            .min_rotation = {
                {{index .Init.MinRotation 0}},
                {{index .Init.MinRotation 1}},
                {{index .Init.MinRotation 2}},
            },
            .max_rotation = {
                {{index .Init.MaxRotation 0}},
                {{index .Init.MaxRotation 1}},
                {{index .Init.MaxRotation 2}},
            },
            .min_angular_velocity = {
                {{index .Init.MinAngularVelocity 0}},
                {{index .Init.MinAngularVelocity 1}},
                {{index .Init.MinAngularVelocity 2}},
            },
            .max_angular_velocity = {
                {{index .Init.MaxAngularVelocity 0}},
                {{index .Init.MaxAngularVelocity 1}},
                {{index .Init.MaxAngularVelocity 2}},
            },
            .min_color = {
                {{index .Init.MinColor 0}},
                {{index .Init.MinColor 1}},
                {{index .Init.MinColor 2}},
            },
            .max_color = {
                {{index .Init.MaxColor 0}},
                {{index .Init.MaxColor 1}},
                {{index .Init.MaxColor 2}},
            },
            .turbulent_velocity = {{.Init.TurbulentVelocity}},
            .turbulent_scale = {{.Init.TurbulentScale}},
            .turbulent_timescale = {{.Init.TurbulentTimeScale}},
            .turbulent_offset = {{.Init.TurbulentOffset}},
            .turbulent_speed_min = {{.Init.TurbulentSpeedMin}},
            .turbulent_speed_max = {{.Init.TurbulentSpeedMax}},
            .turbulent_phase_min = {{.Init.TurbulentPhaseMin}},
            .turbulent_phase_max = {{.Init.TurbulentPhaseMax}},
            .turbulent_forward = {
                {{index .Init.TurbulentForward 0}},
                {{index .Init.TurbulentForward 1}},
                {{index .Init.TurbulentForward 2}},
            },
            .turbulent_right = {
                {{index .Init.TurbulentRight 0}},
                {{index .Init.TurbulentRight 1}},
                {{index .Init.TurbulentRight 2}},
            },
            .turbulent_up = {
                {{index .Init.TurbulentUp 0}},
                {{index .Init.TurbulentUp 1}},
                {{index .Init.TurbulentUp 2}},
            },
        },
        .operator = {
            .movement = {{.Operator.Movement.Enabled}},
            .gravity = {
                {{index .Operator.Movement.Gravity 0}},
                {{index .Operator.Movement.Gravity 1}},
                {{index .Operator.Movement.Gravity 2}},
            },
            .drag = {{.Operator.Movement.Drag}},
            .speed = {{.Operator.Movement.Speed}},
            .angular_movement = {{.Operator.AngularMovement.Enabled}},
            .angular_drag = {{.Operator.AngularMovement.Drag}},
            .angular_force = {
                {{index .Operator.AngularMovement.Force 0}},
                {{index .Operator.AngularMovement.Force 1}},
                {{index .Operator.AngularMovement.Force 2}},
            },
            .oscillate_position = {{.Operator.OscillatePosition.Enabled}},
            .oscillate_mask = {
                {{index .Operator.OscillatePosition.Mask 0}},
                {{index .Operator.OscillatePosition.Mask 1}},
                {{index .Operator.OscillatePosition.Mask 2}},
            },
            .oscillate_frequency_min = {{.Operator.OscillatePosition.FrequencyMin}},
            .oscillate_frequency_max = {{.Operator.OscillatePosition.FrequencyMax}},
            .oscillate_scale_min = {{.Operator.OscillatePosition.ScaleMin}},
            .oscillate_scale_max = {{.Operator.OscillatePosition.ScaleMax}},
            .oscillate_phase_min = {{.Operator.OscillatePosition.PhaseMin}},
            .oscillate_phase_max = {{.Operator.OscillatePosition.PhaseMax}},
            .alpha_fade = {{.Operator.AlphaFade.Enabled}},
            .alpha_fade_in_time = {{.Operator.AlphaFade.FadeInTime}},
            .alpha_fade_out_time = {{.Operator.AlphaFade.FadeOutTime}},
        },
        .spritesheet_cols = {{.SpritesheetCols}},
        .spritesheet_rows = {{.SpritesheetRows}},
        .spritesheet_frames = {{.SpritesheetFrames}},
        .spritesheet_duration = {{.SpritesheetDuration}},
        .sequence_multiplier = {{.SequenceMultiplier}},
        .animation_mode = {{.AnimationMode}},
        .max_count = {{.MaxCount}},
        .emitter_count = {{len .Emitters}},
        .origin = {
            {{index .Origin 0}},
            {{index .Origin 1}},
            {{index .Origin 2}},
        },
    };

{{range $idx, $emitter := .Emitters}}
    particle{{$.ObjectID}}.emitters[{{$idx}}] = (particle_emitter_t){
        .directions = {
            {{index .Directions 0}},
            {{index .Directions 1}},
            {{index .Directions 2}},
        },
        .distance_max = {
            {{index .DistanceMax 0}},
            {{index .DistanceMax 1}},
            {{index .DistanceMax 2}},
        },
        .distance_min = {
            {{index .DistanceMin 0}},
            {{index .DistanceMin 1}},
            {{index .DistanceMin 2}},
        },
        .origin = {
            {{index .Origin 0}},
            {{index .Origin 1}},
            {{index .Origin 2}},
        },
        .sign = {
            {{index .Sign 0}},
            {{index .Sign 1}},
            {{index .Sign 2}},
        },
        .speed_min = {{.SpeedMin}},
        .speed_max = {{.SpeedMax}},
        .interval = 1.0f / {{.Rate}},
        .timer = 0.0f,
    };
{{end}}

    particle{{.ObjectID}}.instance_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(particle_instance_data_t) * {{.MaxCount}});
    init_particle(&particle{{.ObjectID}});
    for(float timer = 0.0f; timer < {{.StartTime}}; timer += 0.05f) {
        update_particle(&particle{{.ObjectID}}, 0.05f);
    }
}
{{end}}

{{define "transform_setup"}}
{{if .Enabled}}
        transform_matrices_t matrices = compute_transform_matrices((transform_parameters_t){
			.scene_width = {{.SceneWidth}},
			.scene_height = {{.SceneHeight}},
			.origin_x = {{.OriginX}},
			.origin_y = {{.OriginY}},
			.origin_z = {{.OriginZ}},
			.size_x = {{.SizeX}},
			.size_y = {{.SizeY}},
			.scale_x = {{.ScaleX}},
			.scale_y = {{.ScaleY}},
			.scale_z = {{.ScaleZ}},
			.parallax_depth_x = {{.ParallaxDepthX}},
			.parallax_depth_y = {{.ParallaxDepthY}},
			.parallax_enabled = {{.ParallaxEnabled}},
			.parallax_amount = {{.ParallaxAmount}},
			.parallax_mouse_influence = {{.ParallaxMouseInfluence}},
			.perspective = {{.Perspective}},
			.near_z = {{.NearZ}},
			.far_z = {{.FarZ}},
			.fov = {{.FOV}},
			.scale_mode = scale_mode,
			.mouse_x = parallax_mouse_x,
			.mouse_y = parallax_mouse_y,
        });
{{else}}
        transform_matrices_t matrices = default_transform_matrices();
{{end}}{{end}}

{{define "pass_init"}}    {{"{"}}
{{if .IsParticle}}
        ow_vertex_binding_info vertex_bindings_info[2] = {
            { .slot = 0, .stride = sizeof(particle_vertex_data_t) },
            { .slot = 1, .stride = sizeof(particle_instance_data_t), .per_instance = true },
        };

        ow_pipeline_info pipeline_info = {
            .vertex_bindings = vertex_bindings_info,
            .vertex_bindings_count = 2,
            .vertex_attributes = particle_vertex_attributes,
            .vertex_attributes_count = 6,
            .color_target_format = {{.ColorTargetFormat}},
            .vertex_shader = particle_vertex,
            .fragment_shader = particle_fragment,
            .blend_mode = {{.BlendMode}},
            .topology = OW_TOPOLOGY_TRIANGLES_STRIP,
        };
{{else}}
        ow_vertex_binding_info vertex_binding_info = {
            .slot = 0,
            .stride = sizeof(vertex_data_t),
        };

        ow_pipeline_info pipeline_info = {
            .vertex_bindings = &vertex_binding_info,
            .vertex_bindings_count = 1,
            .vertex_attributes = vertex_attributes,
            .vertex_attributes_count = 2,
            .color_target_format = {{.ColorTargetFormat}},
            .vertex_shader = shader{{.ShaderID}}_vertex,
            .fragment_shader = shader{{.ShaderID}}_fragment,
            .blend_mode = {{.BlendMode}},
            .topology = OW_TOPOLOGY_TRIANGLES_STRIP,
        };
{{end}}

        object{{.ObjectID}}_pass{{.PassID}}_pipeline = ow_create_pipeline(&pipeline_info);
    {{"}"}}
{{end}}

{{define "pass_update"}}    {{"{"}}
        ow_pass_info pass_info = {0};
        pass_info.color_target = {{.ColorTarget}};
        pass_info.clear_color = {{.ClearColor}};
        ow_begin_render_pass(&pass_info);

        ow_texture_binding texture_bindings[{{len .TextureBindings}}];
        {{range $_, $binding := .TextureBindings}}texture_bindings[{{$binding.Slot}}] = (ow_texture_binding){
            .slot = {{$binding.Slot}},
            .texture = {{$binding.Texture}},
            .sampler = {{$binding.Sampler}},
        };
{{end}}

{{if .IsParticle}}
        ow_id vertex_buffers[2] = {
            particle_vertex_data_buffer,
            particle{{.ObjectID}}.instance_buffer
        };

        ow_bindings_info bindings_info = {
            .vertex_buffers = vertex_buffers,
            .vertex_buffers_count = 2,
            .texture_bindings = texture_bindings,
            .texture_bindings_count = {{len .TextureBindings}},
        };

        particle_vertex_uniforms_t vertex_uniforms = {0};
        particle_fragment_uniforms_t fragment_uniforms = {0};
        fragment_uniforms.spritesheet_size = (glsl_ivec2){ .at = { {{.SpritesheetCols}}, {{.SpritesheetRows}} } };
{{else}}
        ow_bindings_info bindings_info = {
            .vertex_buffers = &vertex_quad_buffer,
            .vertex_buffers_count = 1,
            .texture_bindings = texture_bindings,
            .texture_bindings_count = {{len .TextureBindings}},
        };

        shader{{.ShaderID}}_vertex_uniforms_t vertex_uniforms = {0};
        shader{{.ShaderID}}_fragment_uniforms_t fragment_uniforms = {0};
{{end}}

{{template "transform_setup" .Transform}}

{{.UniformSetupCode}}
        ow_push_uniform_data(OW_SHADER_VERTEX, 0, &vertex_uniforms, sizeof(vertex_uniforms));
        ow_push_uniform_data(OW_SHADER_FRAGMENT, 0, &fragment_uniforms, sizeof(fragment_uniforms));

        ow_render_geometry(object{{.ObjectID}}_pass{{.PassID}}_pipeline, &bindings_info, 0, 4, {{.InstanceCount}});
        ow_end_render_pass();
    {{"}"}}
{{end}}
