{{define "scene"}}// autogenerated by wpe-compile

#include "openwallpaper.h"
#include "openwallpaper_std140.h"

{{range $_, $texture := .Textures}}ow_id texture{{$texture.ID}}; // {{$texture.Name}}
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_header" $shader}}
{{end}}{{range $_, $pass := .Passes}}ow_id object{{$pass.ObjectID}}_pass{{$pass.PassID}}_pipeline;
{{end}}
typedef struct {
    float position[3];
    float texcoord[2];
} vertex_t;

vertex_t vertex_quad[4] = {
    { {-1.0f, -1.0f, 0.0f}, {0.0f, 1.0f} },
    { { 1.0f, -1.0f, 0.0f}, {1.0f, 1.0f} },
    { {-1.0f,  1.0f, 0.0f}, {0.0f, 0.0f} },
    { { 1.0f,  1.0f, 0.0f}, {1.0f, 0.0f} },
};

ow_vertex_attribute vertex_attributes[2] = {
    { .slot = 0, .location = 0, .type = OW_ATTRIBUTE_FLOAT3, .offset = 0 },
    { .slot = 0, .location = 1, .type = OW_ATTRIBUTE_FLOAT2, .offset = sizeof(float) * 3 },
};

ow_id vertex_quad_buffer;
ow_id screen_buffers[3];
ow_id linear_mirror_sampler;

ow_texture_info texture_info = {
    .mip_levels = 1,
    .format = OW_TEXTURE_RGBA8_UNORM,
};

float time = 0.0f;

__attribute__((export_name("init"))) void init() {
    ow_begin_copy_pass();

    vertex_quad_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(vertex_quad));
    ow_update_buffer(vertex_quad_buffer, 0, vertex_quad, sizeof(vertex_quad));

    {
        uint32_t width, height;
        ow_get_screen_size(&width, &height);

        ow_texture_info screen_texture_info = {
            .width = width,
            .height = height,
            .format = OW_TEXTURE_RGBA8_UNORM,
            .render_target = true,
            .mip_levels = 1,
        };

        screen_buffers[1] = ow_create_texture(&screen_texture_info);
        screen_buffers[2] = ow_create_texture(&screen_texture_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_LINEAR,
            .mag_filter = OW_FILTER_LINEAR,
            .mip_filter = OW_FILTER_LINEAR,
            .wrap_x = OW_WRAP_MIRROR,
            .wrap_y = OW_WRAP_MIRROR,
        };

        linear_mirror_sampler = ow_create_sampler(&sampler_info);
    }

{{range $_, $texture := .Textures}}    texture{{$texture.ID}} = ow_create_texture_from_png("assets/texture{{$texture.ID}}.webp", &texture_info);
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_init" $shader}}{{end}}
{{range $_, $pass := .Passes}}{{template "pass_init" $pass}}
{{end}}
    ow_end_copy_pass();
}

__attribute__((export_name("update"))) void update(float delta) {
    time += delta;
{{range $_, $pass := .Passes}}
{{template "pass_update" $pass}}{{end}}
}

{{end}}

{{define "shader_header"}}// {{.NameInfo}}
ow_id shader{{.ID}}_vertex;
ow_id shader{{.ID}}_fragment;

typedef struct {{"{"}}{{range $_, $uniform := .VertexUniforms}}
    glsl_{{$uniform.Type}} {{$uniform.Name}};{{end}}
} shader{{.ID}}_vertex_uniforms_t;

typedef struct {{"{"}}{{range $_, $uniform := .FragmentUniforms}}
    glsl_{{$uniform.Type}} {{$uniform.Name}};{{end}}
} shader{{.ID}}_fragment_uniforms_t;
{{end}}

{{define "shader_init"}}    shader{{.ID}}_vertex = ow_create_shader_from_file("assets/shader{{.ID}}_vertex.spv", OW_SHADER_VERTEX);
    shader{{.ID}}_fragment = ow_create_shader_from_file("assets/shader{{.ID}}_fragment.spv", OW_SHADER_FRAGMENT);
{{end}}

{{define "pass_init"}}    {{"{"}}
        ow_vertex_binding_info vertex_binding_info = {
            .slot = 0,
            .stride = sizeof(vertex_t),
        };

        ow_pipeline_info pipeline_info = {
            .vertex_bindings = &vertex_binding_info,
            .vertex_bindings_count = 1,
            .vertex_attributes = vertex_attributes,
            .vertex_attributes_count = 2,
            .color_target_format = {{.ColorTargetFormat}},
            .vertex_shader = shader{{.ShaderID}}_vertex,
            .fragment_shader = shader{{.ShaderID}}_fragment,
            .blend_mode = OW_BLEND_ALPHA,
            .topology = OW_TOPOLOGY_TRIANGLES_STRIP,
        };

        object{{.ObjectID}}_pass{{.PassID}}_pipeline = ow_create_pipeline(&pipeline_info);
    {{"}"}}
{{end}}

{{define "pass_update"}}    {{"{"}}
        ow_pass_info pass_info = {0};
        pass_info.color_target = screen_buffers[{{.ColorTarget}}];
        pass_info.clear_color = {{.ClearColor}};
        ow_begin_render_pass(&pass_info);

        ow_texture_binding texture_bindings[{{len .TextureBindings}}];
        {{range $_, $binding := .TextureBindings}}texture_bindings[{{$binding.Slot}}] = (ow_texture_binding){
            .slot = {{$binding.Slot}},
            .texture = {{$binding.Texture}},
            .sampler = linear_mirror_sampler,
        };
{{end}}
        ow_bindings_info bindings_info = {
            .vertex_buffers = &vertex_quad_buffer,
            .vertex_buffers_count = 1,
            .texture_bindings = texture_bindings,
            .texture_bindings_count = {{len .TextureBindings}},
        };

        shader{{.ShaderID}}_vertex_uniforms_t vertex_uniforms = {0};
        shader{{.ShaderID}}_fragment_uniforms_t fragment_uniforms = {0};

{{.UniformSetupCode}}
        ow_push_uniform_data(OW_SHADER_VERTEX, 0, &vertex_uniforms, sizeof(vertex_uniforms));
        ow_push_uniform_data(OW_SHADER_FRAGMENT, 0, &fragment_uniforms, sizeof(fragment_uniforms));

        ow_render_geometry(object{{.ObjectID}}_pass{{.PassID}}_pipeline, &bindings_info, 0, 4, 1);
        ow_end_render_pass();
    {{"}"}}
{{end}}

