{{define "scene"}}// autogenerated by wpe-compile

#include <math.h>
#include <stdlib.h>
#include "openwallpaper.h"
#include "scene_utils.h"

typedef struct {
    float position[3];
    float rotation;
    float size;
    float color[4];
    float frame;
} particle_instance_data_t;

{{range $_, $texture := .Textures}}ow_id texture{{$texture.ID}}; // {{$texture.Name}}
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_header" $shader}}
{{end}}{{range $_, $pass := .Passes}}ow_id object{{$pass.ObjectID}}_pass{{$pass.PassID}}_pipeline;
{{end}}
{{range $_, $particle := .Particles}}{{template "particle_header" $particle}}
{{end}}
{{range $_, $particle := .Particles}}{{template "particle_update_func" $particle}}
{{end}}

typedef struct {
    float position[3];
    float texcoord[2];
} vertex_data_t;

typedef struct {
    float texcoord[2];
} particle_vertex_data_t;

typedef struct {
    glsl_mat4 mvp;
} particle_vertex_uniforms_t;

typedef struct {
    glsl_vec2 spritesheet_size;
} particle_fragment_uniforms_t;

vertex_data_t vertex_quad[4] = {
    { {-1.0f, -1.0f, 0.0f}, {0.0f, 1.0f} },
    { { 1.0f, -1.0f, 0.0f}, {1.0f, 1.0f} },
    { {-1.0f,  1.0f, 0.0f}, {0.0f, 0.0f} },
    { { 1.0f,  1.0f, 0.0f}, {1.0f, 0.0f} },
};

particle_vertex_data_t particle_vertex_data[4] = {
    { {0.0f, 1.0f} },
    { {1.0f, 1.0f} },
    { {0.0f, 0.0f} },
    { {1.0f, 0.0f} },
};

ow_vertex_attribute vertex_attributes[2] = {
    { .slot = 0, .location = 0, .type = OW_ATTRIBUTE_FLOAT3, .offset = 0 },
    { .slot = 0, .location = 1, .type = OW_ATTRIBUTE_FLOAT2, .offset = sizeof(float) * 3 },
};

ow_vertex_attribute particle_vertex_attributes[6] = {
    { .slot = 0, .location = 0, .type = OW_ATTRIBUTE_FLOAT2, .offset = 0 },
    { .slot = 1, .location = 1, .type = OW_ATTRIBUTE_FLOAT3, .offset = 0 },
    { .slot = 1, .location = 2, .type = OW_ATTRIBUTE_FLOAT, .offset = sizeof(float) * 3 },
    { .slot = 1, .location = 3, .type = OW_ATTRIBUTE_FLOAT, .offset = sizeof(float) * 4 },
    { .slot = 1, .location = 4, .type = OW_ATTRIBUTE_FLOAT4, .offset = sizeof(float) * 5 },
    { .slot = 1, .location = 5, .type = OW_ATTRIBUTE_FLOAT, .offset = sizeof(float) * 9 },
};

ow_id screen_buffer = 0;
uint32_t screen_buffer_width, screen_buffer_height;

ow_id temp_buffers[{{len .TempBuffers}}];
ow_id temp_screen_buffers[{{len .TempScreenBuffers}}];

ow_id vertex_quad_buffer;
ow_id particle_vertex_data_buffer;

ow_id linear_clamp_sampler;
ow_id linear_repeat_sampler;
ow_id nearest_clamp_sampler;
ow_id nearest_repeat_sampler;

ow_id particle_vertex;
ow_id particle_fragment;

ow_texture_info texture_info = {
    .mip_levels = 1,
    .format = OW_TEXTURE_RGBA8_UNORM,
};

float time = 0.0f;
float mouse_x = 0.0f;
float mouse_y = 0.0f;
float parallax_mouse_x = 0.0f;
float parallax_mouse_y = 0.0f;
bool parallax_initialized = false;
int scale_mode = 2;

__attribute__((export_name("init"))) void init() {
    ow_begin_copy_pass();

    vertex_quad_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(vertex_quad));
    ow_update_buffer(vertex_quad_buffer, 0, vertex_quad, sizeof(vertex_quad));
    particle_vertex_data_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(particle_vertex_data));
    ow_update_buffer(particle_vertex_data_buffer, 0, particle_vertex_data, sizeof(particle_vertex_data));

    particle_vertex = ow_create_shader_from_file("assets/particle_vertex.spv", OW_SHADER_VERTEX);
    particle_fragment = ow_create_shader_from_file("assets/particle_fragment.spv", OW_SHADER_FRAGMENT);

{{range $idx, $buffer := .TempBuffers}}
    {
        ow_texture_info temp_buffer_info = {
            .width = {{$buffer.Width}},
            .height = {{$buffer.Height}},
            .format = OW_TEXTURE_RGBA8_UNORM,
            .render_target = true,
            .mip_levels = 1,
        };

        temp_buffers[{{$idx}}] = ow_create_texture(&temp_buffer_info);
    }
{{end}}

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_LINEAR,
            .mag_filter = OW_FILTER_LINEAR,
            .mip_filter = OW_FILTER_LINEAR,
            .wrap_x = OW_WRAP_CLAMP,
            .wrap_y = OW_WRAP_CLAMP,
        };

        linear_clamp_sampler = ow_create_sampler(&sampler_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_LINEAR,
            .mag_filter = OW_FILTER_LINEAR,
            .mip_filter = OW_FILTER_LINEAR,
            .wrap_x = OW_WRAP_REPEAT,
            .wrap_y = OW_WRAP_REPEAT,
        };

        linear_repeat_sampler = ow_create_sampler(&sampler_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_NEAREST,
            .mag_filter = OW_FILTER_NEAREST,
            .mip_filter = OW_FILTER_NEAREST,
            .wrap_x = OW_WRAP_CLAMP,
            .wrap_y = OW_WRAP_CLAMP,
        };

        nearest_clamp_sampler = ow_create_sampler(&sampler_info);
    }

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_NEAREST,
            .mag_filter = OW_FILTER_NEAREST,
            .mip_filter = OW_FILTER_NEAREST,
            .wrap_x = OW_WRAP_REPEAT,
            .wrap_y = OW_WRAP_REPEAT,
        };

        nearest_repeat_sampler = ow_create_sampler(&sampler_info);
    }

{{range $_, $texture := .Textures}}    texture{{$texture.ID}} = ow_create_texture_from_png("assets/texture{{$texture.ID}}.webp", &texture_info);
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_init" $shader}}{{end}}
{{range $_, $pass := .Passes}}{{template "pass_init" $pass}}
{{end}}
{{range $_, $particle := .Particles}}{{template "particle_init" $particle}}
{{end}}

    ow_end_copy_pass();
}

__attribute__((export_name("update"))) void update(float delta) {
    uint32_t screen_width, screen_height;
    ow_get_screen_size(&screen_width, &screen_height);

    if(screen_width != screen_buffer_width || screen_height != screen_buffer_height) {
        ow_texture_info screen_buffer_info = {
            .width = screen_width,
            .height = screen_height,
            .format = OW_TEXTURE_RGBA8_UNORM,
            .render_target = true,
            .mip_levels = 1,
        };

        ow_free(screen_buffer);
        screen_buffer = ow_create_texture(&screen_buffer_info);

{{range $idx, $buffer := .TempScreenBuffers}}
        screen_buffer_info.width = screen_width * {{$buffer.ScaleX}};
        screen_buffer_info.height = screen_height * {{$buffer.ScaleY}};
        ow_free(temp_screen_buffers[{{$idx}}]);
        temp_screen_buffers[{{$idx}}] = ow_create_texture(&screen_buffer_info);
{{end}}

        screen_buffer_width = screen_width;
        screen_buffer_height = screen_height;
    }

    ow_get_mouse_state(&mouse_x, &mouse_y);
    if(screen_width != 0 && screen_height != 0) {
        mouse_x /= screen_width;
        mouse_y /= screen_height;
    }

    if(!parallax_initialized) {
        parallax_mouse_x = mouse_x;
        parallax_mouse_y = mouse_y;
        parallax_initialized = true;
    }
    if({{.Parallax.Enabled}}) {
        float factor = 1 - exp(-delta * 12.0f / {{.Parallax.Delay}});
        parallax_mouse_x += (mouse_x - parallax_mouse_x) * factor;
        parallax_mouse_y += (mouse_y - parallax_mouse_y) * factor;
    } else {
        parallax_mouse_x = mouse_x;
        parallax_mouse_y = mouse_y;
    }

    ow_begin_copy_pass();

{{range $_, $particle := .Particles}}
    particle{{.ObjectID}}_update(delta);

    for(int i = 0; i < {{.MaxCount}}; i++) {
        particle{{.ObjectID}}.instance_data[i] = (particle_instance_data_t){
            .position = {
                particle{{.ObjectID}}.instances[i].position[0],
                particle{{.ObjectID}}.instances[i].position[1],
                particle{{.ObjectID}}.instances[i].position[2],
            },
            .rotation = {
                particle{{.ObjectID}}.instances[i].rotation[0],
                particle{{.ObjectID}}.instances[i].rotation[1],
                particle{{.ObjectID}}.instances[i].rotation[2],
            },
            .size = particle{{.ObjectID}}.instances[i].size,
            .color = {
                particle{{.ObjectID}}.instances[i].color[0],
                particle{{.ObjectID}}.instances[i].color[1],
                particle{{.ObjectID}}.instances[i].color[2],
                particle{{.ObjectID}}.instances[i].alpha,
            },
            .frame = particle{{.ObjectID}}.instances[i].frame,
        };
    }

    ow_update_buffer(particle{{.ObjectID}}.instance_buffer, 0, particle{{.ObjectID}}.instance_data, sizeof(particle_instance_data_t) * {{.MaxCount}});
{{end}}

    ow_end_copy_pass();

    time += delta;
{{range $_, $pass := .Passes}}
{{template "pass_update" $pass}}{{end}}
}

{{end}}

{{define "shader_header"}}// {{.NameInfo}}
ow_id shader{{.ID}}_vertex;
ow_id shader{{.ID}}_fragment;

{{.VertexUniformsStruct}}
{{.FragmentUniformsStruct}}
{{end}}

{{define "shader_init"}}    shader{{.ID}}_vertex = ow_create_shader_from_file("assets/shader{{.ID}}_vertex.spv", OW_SHADER_VERTEX);
    shader{{.ID}}_fragment = ow_create_shader_from_file("assets/shader{{.ID}}_fragment.spv", OW_SHADER_FRAGMENT);
{{end}}

{{define "particle_header"}}struct {
    ow_id instance_buffer;
    particle_instance_t instances[{{.MaxCount}}];
    particle_instance_data_t instance_data[{{.MaxCount}}];
} particle{{.ObjectID}};
{{end}}

{{define "particle_init"}}    {
        particle{{.ObjectID}}.instance_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(particle_instance_data_t) * {{.MaxCount}});
        for(int i = 0; i < {{.MaxCount}}; i++) {
            particle{{.ObjectID}}.instances[i] = (particle_instance_t){
                .alive = true,
                .position = {rand() % 3840 - 1920, rand() % 2160 - 1080, 0.0f},
                .velocity = {0.0f, -50 - rand() % 41, 0.0f},
                .size = 2 + rand() % 29,
                .color = {1.0f, 1.0f, 1.0f},
                .alpha = 1.0f,
            };
        }
    }
{{end}}

{{define "particle_update_func"}}
void particle{{.ObjectID}}_update(float delta) {
    for(int i = 0; i < {{.MaxCount}}; i++) {
        particle{{.ObjectID}}.instances[i].position[0] += particle{{.ObjectID}}.instances[i].velocity[0] * delta;
        particle{{.ObjectID}}.instances[i].position[1] += particle{{.ObjectID}}.instances[i].velocity[1] * delta;
    }
}
{{end}}

{{define "transform_setup"}}
{{if .Enabled}}
        transform_matrices_t matrices = compute_transform_matrices((transform_parameters_t){
			.scene_width = {{.SceneWidth}},
			.scene_height = {{.SceneHeight}},
			.origin_x = {{.OriginX}},
			.origin_y = {{.OriginY}},
			.origin_z = {{.OriginZ}},
			.size_x = {{.SizeX}},
			.size_y = {{.SizeY}},
			.scale_x = {{.ScaleX}},
			.scale_y = {{.ScaleY}},
			.scale_z = {{.ScaleZ}},
			.parallax_depth_x = {{.ParallaxDepthX}},
			.parallax_depth_y = {{.ParallaxDepthY}},
			.parallax_enabled = {{.ParallaxEnabled}},
			.parallax_amount = {{.ParallaxAmount}},
			.parallax_mouse_influence = {{.ParallaxMouseInfluence}},
			.scale_mode = scale_mode,
			.mouse_x = parallax_mouse_x,
			.mouse_y = parallax_mouse_y,
        });
{{else}}
        transform_matrices_t matrices = default_transform_matrices();
{{end}}{{end}}

{{define "pass_init"}}    {{"{"}}
{{if .IsParticle}}
        ow_vertex_binding_info vertex_bindings_info[2] = {
            { .slot = 0, .stride = sizeof(particle_vertex_data_t) },
            { .slot = 1, .stride = sizeof(particle_instance_data_t), .per_instance = true },
        };

        ow_pipeline_info pipeline_info = {
            .vertex_bindings = vertex_bindings_info,
            .vertex_bindings_count = 2,
            .vertex_attributes = particle_vertex_attributes,
            .vertex_attributes_count = 6,
            .color_target_format = {{.ColorTargetFormat}},
            .vertex_shader = particle_vertex,
            .fragment_shader = particle_fragment,
            .blend_mode = {{.BlendMode}},
            .topology = OW_TOPOLOGY_TRIANGLES_STRIP,
        };
{{else}}
        ow_vertex_binding_info vertex_binding_info = {
            .slot = 0,
            .stride = sizeof(vertex_data_t),
        };

        ow_pipeline_info pipeline_info = {
            .vertex_bindings = &vertex_binding_info,
            .vertex_bindings_count = 1,
            .vertex_attributes = vertex_attributes,
            .vertex_attributes_count = 2,
            .color_target_format = {{.ColorTargetFormat}},
            .vertex_shader = shader{{.ShaderID}}_vertex,
            .fragment_shader = shader{{.ShaderID}}_fragment,
            .blend_mode = {{.BlendMode}},
            .topology = OW_TOPOLOGY_TRIANGLES_STRIP,
        };
{{end}}

        object{{.ObjectID}}_pass{{.PassID}}_pipeline = ow_create_pipeline(&pipeline_info);
    {{"}"}}
{{end}}

{{define "pass_update"}}    {{"{"}}
        ow_pass_info pass_info = {0};
        pass_info.color_target = {{.ColorTarget}};
        pass_info.clear_color = {{.ClearColor}};
        ow_begin_render_pass(&pass_info);

        ow_texture_binding texture_bindings[{{len .TextureBindings}}];
        {{range $_, $binding := .TextureBindings}}texture_bindings[{{$binding.Slot}}] = (ow_texture_binding){
            .slot = {{$binding.Slot}},
            .texture = {{$binding.Texture}},
            .sampler = {{$binding.Sampler}},
        };
{{end}}

{{if .IsParticle}}
        ow_id vertex_buffers[2] = {
            particle_vertex_data_buffer,
            particle{{.ObjectID}}.instance_buffer
        };

        ow_bindings_info bindings_info = {
            .vertex_buffers = vertex_buffers,
            .vertex_buffers_count = 2,
            .texture_bindings = texture_bindings,
            .texture_bindings_count = {{len .TextureBindings}},
        };

        particle_vertex_uniforms_t vertex_uniforms = {0};
        particle_fragment_uniforms_t fragment_uniforms = {0};
{{else}}
        ow_bindings_info bindings_info = {
            .vertex_buffers = &vertex_quad_buffer,
            .vertex_buffers_count = 1,
            .texture_bindings = texture_bindings,
            .texture_bindings_count = {{len .TextureBindings}},
        };

        shader{{.ShaderID}}_vertex_uniforms_t vertex_uniforms = {0};
        shader{{.ShaderID}}_fragment_uniforms_t fragment_uniforms = {0};
{{end}}

{{template "transform_setup" .Transform}}

{{.UniformSetupCode}}
        ow_push_uniform_data(OW_SHADER_VERTEX, 0, &vertex_uniforms, sizeof(vertex_uniforms));
        ow_push_uniform_data(OW_SHADER_FRAGMENT, 0, &fragment_uniforms, sizeof(fragment_uniforms));

        ow_render_geometry(object{{.ObjectID}}_pass{{.PassID}}_pipeline, &bindings_info, 0, 4, {{.InstanceCount}});
        ow_end_render_pass();
    {{"}"}}
{{end}}
