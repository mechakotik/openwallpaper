{{define "scene"}}// autogenerated by wpe-compile

#include "openwallpaper.h"
#include "openwallpaper_std140.h"
#include "scene_utils.h"

{{range $_, $texture := .Textures}}ow_id texture{{$texture.ID}}; // {{$texture.Name}}
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_header" $shader}}
{{end}}{{range $_, $pass := .Passes}}ow_id object{{$pass.ObjectID}}_pass{{$pass.PassID}}_pipeline;
{{end}}
typedef struct {
    float position[3];
    float texcoord[2];
} vertex_t;

vertex_t vertex_quad[4] = {
    { {-1.0f, -1.0f, 0.0f}, {0.0f, 1.0f} },
    { { 1.0f, -1.0f, 0.0f}, {1.0f, 1.0f} },
    { {-1.0f,  1.0f, 0.0f}, {0.0f, 0.0f} },
    { { 1.0f,  1.0f, 0.0f}, {1.0f, 0.0f} },
};

ow_vertex_attribute vertex_attributes[2] = {
    { .slot = 0, .location = 0, .type = OW_ATTRIBUTE_FLOAT3, .offset = 0 },
    { .slot = 0, .location = 1, .type = OW_ATTRIBUTE_FLOAT2, .offset = sizeof(float) * 3 },
};

ow_id temp_buffers[{{len .TempBuffers}}];
ow_id vertex_quad_buffer;
ow_id linear_mirror_sampler;

ow_texture_info texture_info = {
    .mip_levels = 1,
    .format = OW_TEXTURE_RGBA8_UNORM,
};

float time = 0.0f;
float mouse_x = 0.0f;
float mouse_y = 0.0f;
int scale_mode = 2;

__attribute__((export_name("init"))) void init() {
    ow_begin_copy_pass();

    vertex_quad_buffer = ow_create_buffer(OW_BUFFER_VERTEX, sizeof(vertex_quad));
    ow_update_buffer(vertex_quad_buffer, 0, vertex_quad, sizeof(vertex_quad));

{{range $idx, $buffer := .TempBuffers}}
    {
        ow_texture_info temp_texture_info = {
            .width = {{$buffer.Width}},
            .height = {{$buffer.Height}},
            .format = OW_TEXTURE_RGBA8_UNORM,
            .render_target = true,
            .mip_levels = 1,
        };

        temp_buffers[{{$idx}}] = ow_create_texture(&temp_texture_info);
    }
{{end}}

    {
        ow_sampler_info sampler_info = {
            .min_filter = OW_FILTER_LINEAR,
            .mag_filter = OW_FILTER_LINEAR,
            .mip_filter = OW_FILTER_LINEAR,
            .wrap_x = OW_WRAP_MIRROR,
            .wrap_y = OW_WRAP_MIRROR,
        };

        linear_mirror_sampler = ow_create_sampler(&sampler_info);
    }

{{range $_, $texture := .Textures}}    texture{{$texture.ID}} = ow_create_texture_from_png("assets/texture{{$texture.ID}}.webp", &texture_info);
{{end}}
{{range $_, $shader := .Shaders}}{{template "shader_init" $shader}}{{end}}
{{range $_, $pass := .Passes}}{{template "pass_init" $pass}}
{{end}}
    ow_end_copy_pass();
}

__attribute__((export_name("update"))) void update(float delta) {
    uint32_t screen_width, screen_height;
    ow_get_screen_size(&screen_width, &screen_height);

    ow_get_mouse_state(&mouse_x, &mouse_y);
    mouse_x /= screen_width;
    mouse_y /= screen_height;

    time += delta;
{{range $_, $pass := .Passes}}
{{template "pass_update" $pass}}{{end}}
}

{{end}}

{{define "shader_header"}}// {{.NameInfo}}
ow_id shader{{.ID}}_vertex;
ow_id shader{{.ID}}_fragment;

typedef struct {{"{"}}{{range $_, $uniform := .VertexUniforms}}
    glsl_{{$uniform.Type}} {{$uniform.Name}};{{end}}
} shader{{.ID}}_vertex_uniforms_t;

typedef struct {{"{"}}{{range $_, $uniform := .FragmentUniforms}}
    glsl_{{$uniform.Type}} {{$uniform.Name}};{{end}}
} shader{{.ID}}_fragment_uniforms_t;
{{end}}

{{define "shader_init"}}    shader{{.ID}}_vertex = ow_create_shader_from_file("assets/shader{{.ID}}_vertex.spv", OW_SHADER_VERTEX);
    shader{{.ID}}_fragment = ow_create_shader_from_file("assets/shader{{.ID}}_fragment.spv", OW_SHADER_FRAGMENT);
{{end}}

{{define "transform_setup"}}
{{if .Enabled}}
        transform_matrices_t matrices = compute_transform_matrices((transform_parameters_t){
			.scene_width = {{.SceneWidth}},
			.scene_height = {{.SceneHeight}},
			.origin_x = {{.OriginX}},
			.origin_y = {{.OriginY}},
			.origin_z = {{.OriginZ}},
			.size_x = {{.SizeX}},
			.size_y = {{.SizeY}},
			.scale_x = {{.ScaleX}},
			.scale_y = {{.ScaleY}},
			.scale_z = {{.ScaleZ}},
			.parallax_depth_x = {{.ParallaxDepthX}},
			.parallax_depth_y = {{.ParallaxDepthY}},
			.parallax_enabled = {{.ParallaxEnabled}},
			.parallax_amount = {{.ParallaxAmount}},
			.parallax_mouse_influence = {{.ParallaxMouseInfluence}},
			.scale_mode = scale_mode,
			.mouse_x = mouse_x,
			.mouse_y = mouse_y,
        });
{{else}}
        transform_matrices_t matrices = default_transform_matrices();
{{end}}{{end}}

{{define "pass_init"}}    {{"{"}}
        ow_vertex_binding_info vertex_binding_info = {
            .slot = 0,
            .stride = sizeof(vertex_t),
        };

        ow_pipeline_info pipeline_info = {
            .vertex_bindings = &vertex_binding_info,
            .vertex_bindings_count = 1,
            .vertex_attributes = vertex_attributes,
            .vertex_attributes_count = 2,
            .color_target_format = {{.ColorTargetFormat}},
            .vertex_shader = shader{{.ShaderID}}_vertex,
            .fragment_shader = shader{{.ShaderID}}_fragment,
            .blend_mode = OW_BLEND_ALPHA,
            .topology = OW_TOPOLOGY_TRIANGLES_STRIP,
        };

        object{{.ObjectID}}_pass{{.PassID}}_pipeline = ow_create_pipeline(&pipeline_info);
    {{"}"}}
{{end}}

{{define "pass_update"}}    {{"{"}}
        ow_pass_info pass_info = {0};
        pass_info.color_target = {{.ColorTarget}};
        pass_info.clear_color = {{.ClearColor}};
        ow_begin_render_pass(&pass_info);

        ow_texture_binding texture_bindings[{{len .TextureBindings}}];
        {{range $_, $binding := .TextureBindings}}texture_bindings[{{$binding.Slot}}] = (ow_texture_binding){
            .slot = {{$binding.Slot}},
            .texture = {{$binding.Texture}},
            .sampler = linear_mirror_sampler,
        };
{{end}}
        ow_bindings_info bindings_info = {
            .vertex_buffers = &vertex_quad_buffer,
            .vertex_buffers_count = 1,
            .texture_bindings = texture_bindings,
            .texture_bindings_count = {{len .TextureBindings}},
        };

        shader{{.ShaderID}}_vertex_uniforms_t vertex_uniforms = {0};
        shader{{.ShaderID}}_fragment_uniforms_t fragment_uniforms = {0};

{{template "transform_setup" .Transform}}

{{.UniformSetupCode}}
        ow_push_uniform_data(OW_SHADER_VERTEX, 0, &vertex_uniforms, sizeof(vertex_uniforms));
        ow_push_uniform_data(OW_SHADER_FRAGMENT, 0, &fragment_uniforms, sizeof(fragment_uniforms));

        ow_render_geometry(object{{.ObjectID}}_pass{{.PassID}}_pipeline, &bindings_info, 0, 4, 1);
        ow_end_render_pass();
    {{"}"}}
{{end}}
